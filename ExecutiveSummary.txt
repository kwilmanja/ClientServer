Assignment Overview:

The purpose of this assignment was to expose students to RMI and RPC protocols for communication across a network. Remote method invocation allows applications to call methods on objects in foreign JVM's through the utility of the stub/skeleton abstraction. It allows the developer to ignore the underlying serialization of objects and requests, instead delegating this task to a Java library. The assignment also meant to expose us to threaded programming. Threaded programming is a necessary element of distributed systems as it is essential for scalability. Running multiple processes at the same time allows servers to handle a multitude of client requests in a timely and efficient manner. The assignment stresses the importance of mutual exclusion locking and design that factors in synchronous access to important data structures. Without some sense of protection, it is easy for a threaded application to interfere with itself as multiple threads manipulate and access data at the same time, violating any sense of an atomicity and reliability of the data.

Technical Impression:

Using the RMI library was not as complicated nor challenging as I expected it to be when I began the assignment. It was easy to establish a connection by looking up the registry and creating a reference to the remote store. I came to a greater appreciation of the established protocol as it was much easier than the first project where serialization was a major concern. The level of abstraction allows developers to focus more on the service itself and have a general sense of trust in the reliability of the communication mechanism. I was happy to discover that the Java RMI library already is a threaded architecture. I played around with the server and client for quite a while, adding random sleep calls to the threads on both the server and client to ensure the server was handling the requests in different threads. I also log the name of the thread for each server request as well as the timestamp and the action performed. To protect the data, I used a ConcurrentHashMap, as this operates as a thread protected hashmap. Even with this protection, the DELETE and GET operations were left open to failure as both operations first check if the map contains the key, then either removes or retrieves the value. For this, I had to use a synchronized block to ensure that no other threads altered the data while the DELETE / GET operations were being performed. Overall, it was a rewarding experience and a good lesson in threaded programming and RMI.
